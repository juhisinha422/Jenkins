ðŸš€ ð‰ðžð§ð¤ð¢ð§ð¬ ð‹ðžðšð«ð§ð¢ð§ð  ð‰ð¨ð®ð«ð§ðžð² â€“ ðƒðšð² 3: ðŒðšð¬ð­ðžð«-ð’ð¥ðšð¯ðž ðð¨ððž ð’ðžð­ð®ð© & ð‘ðžð¦ð¨ð­ðž ð‰ð¨ð› ð„ð±ðžðœð®ð­ð¢ð¨ð§ ðŸ§ ðŸ–¥ï¸
Today, I explored one of the most powerful features of Jenkins â€” its ability to distribute jobs across multiple nodes. I successfully set up a Linux Slave Node, configured a remote workspace, and executed a Jenkins job on it. Here's what I did step by step:

âš™ï¸ ð—¦ð˜ð—²ð—½ ðŸ­ â€“ ð—¨ð—»ð—±ð—²ð—¿ð˜€ð˜ð—®ð—»ð—±ð—¶ð—»ð—´ ð—ð—²ð—»ð—¸ð—¶ð—»ð˜€ ð—”ð—¿ð—°ð—µð—¶ð˜ð—²ð—°ð˜ð˜‚ð—¿ð—²
ðŸ”¹ Jenkins uses a Master-Slave model (now called Controller-Agent)
ðŸ”¹ Master (controller) handles the UI, scheduling, and job coordination
ðŸ”¹ Slave (agent) performs the actual job execution when assigned

ðŸ–¥ï¸ ð—¦ð˜ð—²ð—½ ðŸ® â€“ ð—”ð—±ð—±ð—¶ð—»ð—´ ð—® ð—Ÿð—¶ð—»ð˜‚ð˜… ð—¦ð—¹ð—®ð˜ƒð—² ð—¡ð—¼ð—±ð—²
ðŸ”¹ On my Jenkins master, I navigated to:
 Manage Jenkins > Manage Nodes and Clouds > New Node
ðŸ”¹ Created a node named Linux_Slave_Node_1
ðŸ”¹ Set the node type as Permanent Agent
ðŸ”¹ Configured:
 - Remote root directory: /home/ec2-user/Jenkins_Workspace
 - Number of executors: 1
 - Usage: Use this node as much as possible
ðŸ”¹ Set the launch method to "Launch agents via SSH" and provided:
 - Host IP
 - SSH credentials
 - Port
âœ… Once saved, the slave node connected successfully!

ðŸ“ ð—¦ð˜ð—²ð—½ ðŸ¯ â€“ ð—–ð—¿ð—²ð—®ð˜ð—¶ð—»ð—´ ð—ªð—¼ð—¿ð—¸ð˜€ð—½ð—®ð—°ð—² ð—¼ð—» ð—¦ð—¹ð—®ð˜ƒð—² ð—¡ð—¼ð—±ð—²
ðŸ”¹ Logged into the slave node and created a directory:
 mkdir -p /home/ec2-user/Jenkins_Workspace

ðŸ”¹ Made sure Jenkins had permission to use it as the working directory for job execution.

ðŸ§ª ð—¦ð˜ð—²ð—½ ðŸ° â€“ ð—˜ð˜…ð—²ð—°ð˜‚ð˜ð—¶ð—»ð—´ ð—® ð—ð—¼ð—¯ ð—¼ð—» ð˜ð—µð—² ð—¦ð—¹ð—®ð˜ƒð—² ð—¡ð—¼ð—±ð—²
ðŸ”¹ Back in Jenkins, I created a new freestyle project
ðŸ”¹ In the "Restrict where this project can be run" section, I specified the label of the slave node:- Linux_Slave_Node_1
ðŸ”¹ Added a simple shell command in the build step:
 echo "Hello from Slave Node!" > hello_slave.txt

âœ… Triggered the job â€” it executed on the slave node and created the

output file in /home/ec2-user/Jenkins_Workspace.

ðŸŽ¯ Why This Matters
âœ¨ Workload Distribution: Spread builds across machines to improve performance
 âœ¨ OS Flexibility: Run specific jobs on specific platforms (Linux/Windows/Mac)
 âœ¨ Better Resource Management: Avoid overloading the Jenkins master
ðŸ§  What I Learned Today
ðŸ”¸ Jenkins can scale using agent nodes
 ðŸ”¸ Setting up SSH-based remote nodes is simple and powerful
 ðŸ”¸ Jobs can run independently across environments with their own workspace
 ðŸ”¸ Understanding the executor system helps manage CI/CD pipelines effectively
